# 搜索
搜索题目本质就是将题目中的状态映射为图中的点，将状态间的联系映射为图中的边。根据题目信息构建状态空间，然后对状态空间进行遍历，遍历过程需要记录和维护状态，并通过剪枝和数据结构等提高搜索效率。

## 状态空间

**状态空间其实就是一个图结构，图中的节点表示状态，图中的边表示状态之前的联系，这种联系就是题目给出的各种关系**。

## DFS 和 BFS

DFS 和 BFS 是搜索的核心，贯穿搜索篇的始终，因此有必要先对其进行讲解。

### DFS

题目的**状态空间映射到一张图，状态就是图中的节点，状态之间的联系就是图中的边**，那么 DFS 就是在这种图上进行**深度优先**的遍历。而 BFS 也是类似，只不过遍历的策略变为了**广度优先**，一层层铺开而已。

- 常见的DFS用来解决什么问题？(1) 图中（有向无向皆可）的符合某种特征（比如最长）的路径以及长度（2）排列组合（3） 遍历一个图（或者树）（4）找出图或者树中符合题目要求的全部方案
- DFS基本模板（需要记录路径，不需要返回值 and 不需要记录路径，但需要记录某些特征的返回值）
- 除了遍历之外多数情况下时间复杂度是指数级别，一般是O(方案数×找到每个方案的时间复杂度)
- 递归题目都可以用非递归迭代的方法写，但一般实现起来非常麻烦

#### 算法模板

下面我们借助递归来完成 DFS。

```java
boolean[] visited = new boolean[n];

private void dfs(int i) {
    if (满足特定条件) {
        // 返回结果 or 退出搜索空间
    }
    visited[i] = true;
    for (根据 i 能到达的下一个状态 j) {
        if (!visited[j]) { // 如果状态 j 没有被搜索过
            dfs(j);
        }
    }
}
```

#### 例题

[543. 二叉树的直径](../problems/LeetCode543.java) (简单) （分治）

[124. 二叉树中的最大路径和](../problems/LeetCode124.java) (困难)（分治）

[226. 翻转二叉树](../problems/LeetCode226.java) (简单)（分治）

[101. 翻转二叉树](../problems/LeetCode101.java) (简单)（分治）

[951. 翻转等价二叉树](../problems/LeetCode951.java) (中等)（分治）

[236. 二叉树的最近公共祖先](../problems/LeetCode236.java) (中等)（回溯 or 分治）

[105. 从前序与中序遍历序列构造二叉树](../problems/LeetCode105.java) (中等)（分治）

[104. 二叉树的最大深度](../problems/LeetCode104.java) (简单)（回溯 or 分治）